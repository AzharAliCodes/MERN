ðŸ”¹ 1. Controlled Components in React

A Controlled Component is a form element (like <input>, <textarea>, etc.) whose value is controlled by React state.

 ðŸ”¸ How It Works:

 You use useState to hold the value.
 You update the value using an onChange event handler.

 âœ… Example:

jsx
import React, { useState } from 'react';

function ControlledForm() {
  const [name, setName] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(Submitted name: ${name});
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input 
          type="text" 
          value={name}
          onChange={(e) => setName(e.target.value)} 
        />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default ControlledForm;


ðŸ§  Key Points:

 value is tied to the name state.
 React has full control over the input.

---

 ðŸ”¹ 2. Uncontrolled Components in React

An Uncontrolled Component is a form element where the data is managed by the DOM, not React.

 ðŸ”¸ How It Works:

 You use useRef to directly access the DOM node and its value.

 âœ… Example:

jsx
import React, { useRef } from 'react';

function UncontrolledForm() {
  const nameRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(Submitted name: ${nameRef.current.value});
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" ref={nameRef} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default UncontrolledForm;


ðŸ§  Key Points:

 No useState is used.
 useRef gives access to DOM elements.

---

 ðŸ”¹ 3. useRef Hook in Detail

 ðŸ”¸ Syntax:

jsx
const ref = useRef(initialValue);


 ðŸ”¸ Features:

 Used to reference DOM elements.
 Can also store mutable values that donâ€™t cause re-renders.

 âœ… Example 1: Accessing DOM element

jsx
function FocusInput() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus();
  };

  return (
    <>
      <input type="text" ref={inputRef} />
      <button onClick={handleClick}>Focus Input</button>
    </>
  );
}


 âœ… Example 2: Storing a value without re-render

jsx
function Timer() {
  const count = useRef(0);

  const increment = () => {
    count.current += 1;
    console.log(count.current); // Value updates without re-render
  };

  return <button onClick={increment}>Click Me</button>;
}


---

 ðŸ”¹ 4. Storing and Updating Object in useState

You can store an object in useState and update individual keys without overwriting the entire object.

 âœ… Example:

jsx
import React, { useState } from 'react';

function ProfileForm() {
  const [user, setUser] = useState({
    name: '',
    age: '',
    email: ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setUser((prevUser) => ({
      ...prevUser,
      [name]: value
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(user);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input 
        type="text"
        name="name"
        value={user.name}
        onChange={handleChange}
        placeholder="Name"
      />
      <input 
        type="number"
        name="age"
        value={user.age}
        onChange={handleChange}
        placeholder="Age"
      />
      <input 
        type="email"
        name="email"
        value={user.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <button type="submit">Submit</button>
    </form>
  );
}


 ðŸ§  Explanation:

 The state user holds an object.
 setUser uses the spread operator to preserve other fields.
 [name]: value dynamically updates only the changed field.

